#PARSER PQL
#DROPALLQUERIES
#QUERY

matchstart = SELECT({predicate = 'timestamp > 10753478619424000'}, soccergame)

included_metadata = ENRICH({minimumSize = 42, PREDICATE = RelationalPredicate('sensorid = sid')}, System.metadata, matchstart)

included_interruptions = join({predicate = 'timestamp >= start_interruption && timestamp <= end_interruption && playing == true', CARD = 'MANY_ONE'}, included_metadata, System.interruptions)

///remove referee and goalkeeper hands
without_referee = SELECT({predicate = 'entity_id != 21 && sensorid != 97 && sensorid != 98 && sensorid != 99 && sensorid != 100'}, included_interruptions)

///sensor_data must be inside the game field
inFieldX = SELECT({predicate = 'sens_x > -50 && sens_x < 52489'}, without_referee)
inFieldXY = SELECT({predicate = 'sens_y > -33939 && sens_y < 33965'}, inFieldX)

///TODO: replace both selects by one filter statement?!
ball_events = SELECT({predicate = 'entity = "Ball"'}, inFieldXY)
ball_events_projection = PROJECT({attributes = ['sid', 'timestamp', 'sens_x', 'sens_y', 'sens_z', 'sens_speed', 'accel', 'speed_x', 'speed_y', 'speed_z', 'accel_x', 'accel_y', 'accel_z']}, ball_events)
player_events = SELECT({predicate = 'entity != "Ball"'}, inFieldXY)
player_events_projection = PROJECT({attributes = ['entity', 'sensorid', 'team_id', 'timestamp', 'sens_x', 'sens_y', 'sens_z']}, player_events)
///maybe renaming timestampp to player_time or ball_hit_time
player_events_renaming = RENAME({aliases = ['name', 'player_id', 'team_id', 'timestampp', 'sensor_x', 'sensor_y', 'sensor_z']}, player_events_projection)

///add the acceleration and sid values of the previous data line to the current to be able to detect changes
previous_ball_event_sid = STATEMAP({expressions = ['sid', ['__last_1.sid', 'last_sid'], 'timestamp', 'sens_x', 'sens_y', 'sens_z', 'sens_speed', 'accel', ['__last_1.accel', 'last_accel'], 'speed_x', 'speed_y', 'speed_x', 'accel_x', 'accel_y', 'accel_z', ['(sens_x > 22578.5 && sens_x < 29898.5 && sens_y = 33941.0 && sens_z < 2440.0) || (sens_x > 22560.0 && sens_x < 29880.0 && sens_y = -33968.0 && sens_z < 2440.0)', 'in_goal_area']]}, ball_events_projection)

zero_point_five_second_intervall = TIMEWINDOW({size = 500000000000, advance = 500000000000}, previous_ball_event_sid)

///aggregate the values required for the goal shot computation, like acceleration and events. Save the other values by using the first statement which are required for data presentation and further computation.
///max of a boolean value is true, min is false
preparing_data_for_goal_shot_detection = COALESCE({predicate='sid = last_sid && (accel + 10 >= last_accel || accel - 10 <= last_accel) ', AGGREGATIONS=[['first','sid','sid'], ['first','timestamp','start_timestamp'], ['last','timestamp','end_timestamp'], ['count','timestamp','event_count'], ['sum','accel','acceleration_sum'], ['max','in_goal_area','in_goal_area'], ['first','sens_x','sens_x'], ['first','sens_y','sens_y'], ['first','sens_z','sens_z']]}, zero_point_five_second_intervall)

one_second_intervall = TIMEWINDOW({size = 1000000000000, advance = 1000000000000}, preparing_data_for_goal_shot_detection)

///select where acceleration >= 55 m/s^2
sufficient_acceleration = SELECT({predicate = '(acceleration_sum/event_count)/10^10 >= 55'}, one_second_intervall)

one_point_five_second_intervall = TIMEWINDOW({size = 1500000000000, advance = 1500000000000}, sufficient_acceleration)

///must be in goal area at least in one event
reached_goal_area = SELECT({predicate = 'in_goal_area = true'}, one_point_five_second_intervall)

///TODO: adapt attribute names from aggregations: actually replace timestamp by start_timestamp
///detect ball shooter
///ball and player are in same area with 1m tolerance and at same time with 1ms tolerance
ball_with_player_at_same_timestamp = join({predicate = '(timestamp + 1000000000 >= timestampp && timestamp <= timestampp) || (timestamp - 1000000000 <= timestampp && timestamp >= timestampp)', CARD = 'ONE_MANY'}, reached_goal_area, player_events_renaming)
ball_with_player_nearby = SELECT({predicate = '((sens_x + 1000 >= sensor_x && sens_x <= sensor_x) || (sens_x - 1000 <= sensor_x && sens_x >= sensor_x)) && ((sens_y + 1000 >= sensor_y && sens_y <= sensor_y) || (sens_y - 1000 <= sensor_y && sens_y >= sensor_y)) && ((sens_z + 1000 >= sensor_z && sens_z <= sensor_z) || (sens_z - 1000 <= sensor_z && sens_z >= sensor_z))'}, ball_with_player_at_same_timestamp)
ball_player_projection = PROJECT({attributes = ['sid', 'timestamp', 'sens_x', 'sens_y', 'sens_z', 'sens_speed', 'accel', 'speed_x', 'speed_y', 'speed_x', 'accel_x', 'accel_y', 'accel_z', 'name', 'player_id', 'team_id', 'timestampp' ]}, ball_with_player_nearby)

///select where player shoots on opponents goal and to exclude return passes by using team_id and timestamp to identify the sides. y > 0 means left side and vice versa
///TODO: adapt attribute names from aggregations: actually replace timestamp by start_timestamp
ball_with_halfsides = join({predicate = 'timestamp >= halftime_start && timestamp <= halftime_end && team_id = team'}, ball_player_projection, System.goals)
only_opponents_shots = SELECT({predicate = '(side = "right" && sens_y < 0) || (side = "left" && sens_y > 0)'}, halfside_joined)
