#PARSER PQL
#DROPALLQUERIES
#QUERY

matchstart = SELECT({predicate = 'timestamp > 10753478619424000'}, soccergame)

included_metadata = ENRICH({minimumSize = 42, PREDICATE = RelationalPredicate('sensorid = sid')}, System.metadata, matchstart)

included_interruptions = join({predicate = 'timestamp >= start_interruption && timestamp <= end_interruption && playing == true', CARD = 'MANY_ONE'}, included_metadata, System.interruptions)

///remove referee and goalkeeper hands
without_referee = SELECT({predicate = 'entity_id != 21 && sensorid != 97 && sensorid != 98 && sensorid != 99 && sensorid != 100'}, included_interruptions)

///sensor_data must be inside the game field
inFieldX = SELECT({predicate = 'sens_x > -50 && sens_x < 52489'}, without_referee)
inFieldXY = SELECT({predicate = 'sens_y > -33939 && sens_y < 33965'}, inFieldX)

///TODO: replace both selects by one filter statement?!
ball_events = SELECT({predicate = 'entity = "Ball"'}, inFieldXY)
ball_events_projection = PROJECT({attributes = ['sid', 'timestamp', 'sens_x', 'sens_y', 'sens_z', 'sens_speed', 'accel', 'speed_x', 'speed_y', 'speed_z', 'accel_x', 'accel_y', 'accel_z']}, ball_events)
player_events = SELECT({predicate = 'entity != "Ball"'}, inFieldXY)
player_events_projection = PROJECT({attributes = ['entity', 'sensorid', 'team_id', 'timestamp', 'sens_x', 'sens_y', 'sens_z']}, player_events)
player_events_renaming = RENAME({aliases = ['name', 'player_id', 'team_id', 'player_hit_timestamp', 'sensor_x', 'sensor_y', 'sensor_z']}, player_events_projection)

///add the acceleration and sid values of the previous data line to the current to be able to detect changes
previous_ball_event_sid = STATEMAP({expressions = ['sid', ['__last_1.sid', 'last_sid'], 'timestamp', 'sens_x', 'sens_y', 'sens_z', 'sens_speed', 'accel', ['__last_1.accel', 'last_accel'], 'speed_x', 'speed_y', 'speed_z', 'accel_x', 'accel_y', 'accel_z', ['(sens_x > 22578.5 && sens_x < 29898.5 && sens_y = 33941.0 && sens_z < 2440.0) || (sens_x > 22560.0 && sens_x < 29880.0 && sens_y = -33968.0 && sens_z < 2440.0)', 'in_goal_area']]}, ball_events_projection)

///detect ball shooter
///ball and player are in same area with 1m tolerance and at same time with 1ms tolerance
ball_with_player_at_same_timestamp = join({predicate = '(timestamp + 1000000000 >= player_hit_timestamp && timestamp <= player_hit_timestamp) || (timestamp - 1000000000 <= player_hit_timestamp && timestamp >= player_hit_timestamp)', CARD = 'ONE_MANY'}, previous_ball_event_sid, player_events_renaming)
ball_with_player_nearby = SELECT({predicate = '((sens_x + 1000 >= sensor_x && sens_x <= sensor_x) || (sens_x - 1000 <= sensor_x && sens_x >= sensor_x)) && ((sens_y + 1000 >= sensor_y && sens_y <= sensor_y) || (sens_y - 1000 <= sensor_y && sens_y >= sensor_y)) && ((sens_z + 1000 >= sensor_z && sens_z <= sensor_z) || (sens_z - 1000 <= sensor_z && sens_z >= sensor_z))'}, ball_with_player_at_same_timestamp)
ball_player_projection = PROJECT({attributes = ['sid', 'timestamp', 'sens_x', 'sens_y', 'name', 'player_id', 'team_id']}, ball_with_player_nearby)

///select where player shoots on opponents goal and to exclude return passes by using team_id and timestamp to identify the sides. y > 0 means left side and vice versa
ball_with_halfsides = join({predicate = 'timestamp >= halftime_start && timestamp <= halftime_end && team_id = team'}, ball_player_projection, System.goals)
only_opponents_shots = SELECT({predicate = '(side = "right" && sens_y > 0) || (side = "left" && sens_y < 0)'}, ball_with_halfsides)

ball_player_remove_useless_attributes = PROJECT({attributes = ['sid', 'timestamp', 'name', 'player_id']}, only_opponents_shots)
ball_player_renaming = RENAME({aliases = ['sensorid', 'ball_hit_timestamp', 'name', 'player_id']}, ball_player_remove_useless_attributes)

///TODO: rename second stream to avoid naming problems
all_possible_goal_shots_with_events = join({predicate = 'ball_hit_timestamp + 1500000000 >= timestamp && sensorid = sid'}, ball_player_renaming, previous_ball_event_sid)

///select where acceleration >= 55 m/s^2
///TODO: divide through last - first timestamp instead of 1s
preparing_data_for_sufficient_acceleration = COALESCE({predicate='ball_hit_timestamp + 1000000000 >= timestamp && (accel + 10 >= last_accel || accel - 10 <= last_accel)', AGGREGATIONS=[['first','sensorid','sid'], ['first','ball_hit_timestamp','ball_hit_timestamp'], ['last','timestamp','end_timestamp'], ['count','timestamp','event_count'], ['sum','accel','acceleration_sum'], ['first','sens_x','sens_x'], ['first','sens_y','sens_y'], ['first','sens_z','sens_z']]}, all_possible_goal_shots_with_events)
sufficient_acceleration = SELECT({predicate = '((acceleration_sum/event_count*1000)/((end_timestamp - ball_hit_timestamp))/1000000000000) >= 55'}, preparing_data_for_sufficient_acceleration)

///aggregate the values required for the goal shot computation, like acceleration and events. Save the other values by using the first statement which are required for data presentation and further computation.
///max of a boolean value is true, min is false
///TODO: coalesce does not work
preparing_data_for_reached_goal_area = COALESCE({predicate='(accel + 10 >= last_accel || accel - 10 <= last_accel)', AGGREGATIONS=[['first','sid','sid'], ['first','ball_hit_timestamp','ball_hit_timestamp2'], ['max','in_goal_area','in_goal_area']]}, all_possible_goal_shots_with_events)
///must be in goal area at least in one event
reached_goal_area = SELECT({predicate = 'in_goal_area = true'}, preparing_data_for_reached_goal_area)

goal_shots = join({predicate = 'ball_hit_timestamp = ball_hit_timestamp2 && sensorid = sid'}, sufficient_acceleration, reached_goal_area)
